package top100;

/**
 * 给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。
 * <p>
 * 请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。
 */
public class Code041 {
    public int firstMissingPositive(int[] nums) {
        // 缺失的第一个正数
        // 双指针
        // 从0-left  0位置的放1 1位置放2 2位置放3
        // right到之前是需要放弃位置
        int N = nums.length;
        int left = 0;
        // 垃圾区
        int right = N - 1;
        while (left <= right) {
            if (nums[left] == left + 1) {
                left++;
            }
            // 发放到垃圾区的条件
            // 本意是为了0位置放1 1位置放2 2位置放3.。。。
            // 第一种情况 当前位left来到了4位置 但是当前位置是3
            // 第二种情况当前值是5 但是后面4位置已经有了一个5
            // 第三种情况假设垃圾区的index是8 那么说明可能缺失的正数在1-9 突然来了10
            else if (nums[left] < left + 1 || nums[left] > right + 1 || nums[nums[left] - 1] == nums[left]) {
                swap(nums, left, right--);
            } else {
                // 交换
                // 当前位置是5 就将他发配到index = 4的位置 当前left不做处理
                swap(nums, nums[left] - 1, left);
            }
        }
        return left + 1;
    }

    public int firstMissingPositive2(int[] nums) {
        // 缺失的第一个正数
        // 双指针
        // 从0-left  0位置的放1 1位置放2 2位置放3
        // right到之前是需要放弃位置
        int N = nums.length;
        int left = 0;
        // 垃圾区
        int right = N;
        while (left < right) {
            if (nums[left] == left + 1) {
                left++;
            }
            // 发放到垃圾区的条件
            // 本意是为了0位置放1 1位置放2 2位置放3.。。。
            // 第一种情况 当前位left来到了4位置 但是当前位置是3
            // 第二种情况当前值是5 但是后面4位置已经有了一个5
            // 第三种情况假设垃圾区的index是8 那么说明可能缺失的正数在1-9 突然来了10
            else if (nums[left] < left + 1 || nums[left] > right || nums[nums[left] - 1] == nums[left]) {
                swap(nums, left, --right);
            } else {
                // 交换
                // 当前位置是5 就将他发配到index = 4的位置 当前left不做处理
                swap(nums, nums[left] - 1, left);
            }
        }
        return left + 1;
    }

    /**
     * 想象有一间教室，座位从左到右编号为1到N
     * 有N个学生坐在教室的座位上，把nums[i]当做坐在第i个座位上的学生学好，我们要做的事情，就是让学号在
     * 1~N中的学生，都坐到编号与自己学号想通的座位上（学号与学位编码匹配）。学号不在[1,N]中的学生可以忽略
     * <p>
     * 学生们交换座位之后，从左往右看，第一个学号与座位编号不匹配的学生，其座位编号就是答案
     * 特别地：如果所有的学生都坐在座位上，那么答案就是N+1
     * 第一个例子：
     * 为方便描述思路：假设数组的下标是从1开始的
     * 假设nums = [2,3,1]
     * 1.从nums[1]开始，这个座位上的学生，学号是2，他应该坐在nums[2]上，所以他和nums[2]交换，交换后nums=[3,2,1]
     * 2.仍然看nums[1]，这个座位上的学生，学号是3，他 应该坐在nums[3]上，所以他和nums[3]交换，交换后nums=[1,2,3]
     * 3,。仍然看nums[1]，这个座位上的学生，学号是1，他已经坐在正确的座位上了，我们看下一个座位
     * 4.看nums[2]，这个座位上的学生，学号是2，他已经坐在正确的座位上了，我们看下一个座位
     * 5.看nums[3]，这个座位上的学生，学号是3，他已经坐在正确的座位上了，我们看下一个座位
     * 6.换座位过程结束
     * 7.从左往右看，第一个学号与座位编号不匹配的学生，没有，说明所有的学生都坐在正确的座位上，所以答案是N+1=4
     * <p>
     * 第二个例子：
     * 假设nums = [3,4,-1,1] 这是原始题目给的示例2
     * 1.从nums[1]开始，这个座位上的学生，学号是3，他应该坐在nums[3]上，所以他和nums[3]交换，交换侯nums=[-1,4,3,1]
     * 2.仍然看nums[1]，这个座位上的学生，学号是-1，他的学号不在[1,N]中，忽略他
     * 3.向后遍历nums[2]=4 他应该坐在nums[4]上，所以他和nums[4]交换，交换后nums=[-1,1,3,4]
     * 4.仍然看nums[2]，这个座位上的学生，学号是1，他应该坐在nums[1]上，所以他和nums[1]交换，交换后nums=[1,-1,3,4]
     * 5.仍然看nums[2]，这个座位上的学生，学号是-1，他的学号不在[1,N]中，忽略他
     * 6.向后遍历nums[3]=3 他已经坐在正确的座位上了，我们看下一个座位
     * 7.向后遍历nums[4]=4 他已经坐在正确的座位上了，我们看下一个座位
     * 8.换座位过程结束
     * 9.从左往右看，第一个学号与座位编号不匹配的学生是nums[2]，他的学号是-1，座位编号是2，所以答案是2
     * <p>
     * 第三个例子：
     * 注意nums可能有重复元素，在这种情况下，算法仍然是正确的吗？
     * 假设nums = [1,1,2]
     * 1.从nums[1]开始，这个位置上的学生，坐在正确的座位上了，我们看下一个座位
     * 2.向后遍历nums[2]=1 他应该坐在nums[1]上，但是nums[1]上已经有一个学号为1的学生了，我们可以在第二次便利中知道
     * 数组中 有1 这个信息，所以可以忽略nums[2]继续向后遍历
     * 3.nums[3]=2 他应该坐在nums[2]上，所以他和nums[2]交换，交换后nums=[1,2,1]
     * 4.仍然看nums[3]=1 他应该坐在nums[1]上，但是nums[1]上已经有一个学号为1的学生了，我们可以忽略nums[3]继续向后遍历
     * 5.换座位过程结束
     * 6.再次遍历nums发现nums[3] !=3 说明教室中没有编号为3的学生，所以答案是3
     * <p>
     * 细节：
     * 判断【学生是否在正确的座位上】，能用nums[i] = i吗？注意有影分身（重复元素）
     * 在第三个例子中，虽然nums[2] = 1   ！= 2 但是由于nums[nums[2]] = nums[1] = 1 所以nums[2]是个影分身
     * 并且真身坐在了正确的位置撒好难过，所以可以忽略nums[2]，向后遍历。注意这种情况是不能交换的，因为nums[2]=nums[1]
     * 交换侯nums=[1,1,2]是不变的，会导致死循环
     * 为避免死循环，可以改成判断nums[i] = nums[nums[i]]  ，如果相等，说明nums[i]是影分身，可以忽略
     * <p>
     * 一般地，为了兼容【当前学生是真身，坐在正确的位置上】和【当前学生是影分身，且真身坐在正确的位置上】，两种情况
     * 可以改成判断nums[i] = nums[nums[i]]
     * <p>
     * 无论【当前学生是真身，坐在正确的位置上】还是【当前学生是影分身，且真身坐在正确的座位上】上式都是成立的
     * <p>
     * 如果【当前学生是真身，不坐在正确的位置上】那么上式左边是当前学生的学号，右边是要交换位置的学生的学号
     * 如果【当前学生是影分身，且真身不坐在位置上】那么上式左边是当前学生的学号，右边是要交换的学生的学号，虽然是用影分身交换的
     * 但是交换后，可以认为真身已经坐在了正确的位置上了
     *
     * @param nums
     * @return
     */
    public int firstMissingPositive3(int[] nums) {
        int N = nums.length;
        for (int i = 0; i < nums.length; i++) {
            while (nums[i] >= 1 && nums[i] <= N && nums[i] != nums[nums[i] - 1]) {
                swap(nums, i, nums[i] - 1);
            }
        }
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }
        return N + 1;
    }

    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
